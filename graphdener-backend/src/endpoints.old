use datastore::ProxyTransaction;
use datastore::{datastore, ProxyDatastore};
use indradb::{EdgeDirection, EdgeKey, EdgeQuery, Error, Transaction, Type, Vertex, VertexQuery};
use iron::headers::{ContentType, Encoding, Headers, TransferEncoding};
use iron::prelude::*;
use iron::status;
use iron::typemap::TypeMap;
use lazy_static::*;
use serde::ser::Serialize;
use serde_json;
use serde_json::value::Value as JsonValue;
use std::thread::spawn;
use uuid::Uuid;
use std::io;
use iron::request::Body;

lazy_static! {
    /// The underlying datastore
    pub static ref DATASTORE: ProxyDatastore = 1();
}




pub fn transaction(req: &mut Request) -> IronResult<Response> {
    let trans = get_transaction()?;
    let mut jsonable_res: Vec<JsonValue> = Vec::new();
    let body: Vec<JsonValue> = read_json(&mut req.body)?.unwrap_or_else(Vec::new);

    for (idx, item) in body.into_iter().enumerate() {
        if let JsonValue::Object(obj) = item {
            let action = get_json_obj_value::<String>(&obj, "action").map_err(|err| {
                let message = format!("Item #{}: {}", idx, err);
                create_iron_error(status::BadRequest, message)
            })?;

            let result: Result<JsonValue, IronError> = match &action[..] {
                "create_vertex" => create_vertex(&trans, &obj),
                "create_vertex_from_type" => create_vertex_from_type(&trans, &obj),
                "get_vertices" => get_vertices(&trans, &obj),
                "delete_vertices" => delete_vertices(&trans, &obj),
                "get_vertex_count" => get_vertex_count(&trans, &obj),

                "create_edge" => create_edge(&trans, &obj),
                "get_edges" => get_edges(&trans, &obj),
                "delete_edges" => delete_edges(&trans, &obj),
                "get_edge_count" => get_edge_count(&trans, &obj),

                "get_vertex_metadata" => get_vertex_metadata(&trans, &obj),
                "set_vertex_metadata" => set_vertex_metadata(&trans, &obj),
                "delete_vertex_metadata" => delete_vertex_metadata(&trans, &obj),

                "get_edge_metadata" => get_edge_metadata(&trans, &obj),
                "set_edge_metadata" => set_edge_metadata(&trans, &obj),
                "delete_edge_metadata" => delete_edge_metadata(&trans, &obj),

                _ => Err(create_iron_error(status::BadRequest, "Unknown action".to_string())),
            };

            match result {
                Err(err) => {
                    let message = format!("Item #{}: {}", idx, err);
                    return Err(create_iron_error(status::BadRequest, message));
                }
                Ok(value) => {
                    jsonable_res.push(value);
                }
            }
        } else {
            return Err(create_iron_error(
                status::BadRequest,
                format!("Item #{}: Invalid type", idx),
            ));
        }
    }

    Ok(to_response(status::Ok, &jsonable_res))
}

fn create_vertex(trans: &ProxyTransaction, item: &serde_json::Map<String, JsonValue>) -> Result<JsonValue, IronError> {
    let v = get_json_obj_value::<Vertex>(item, "vertex")?;
    execute_item(trans.create_vertex(&v))
}

fn create_vertex_from_type(
    trans: &ProxyTransaction,
    item: &serde_json::Map<String, JsonValue>,
) -> Result<JsonValue, IronError> {
    let t = get_json_obj_value::<Type>(item, "type")?;
    execute_item(trans.create_vertex_from_type(t))
}

fn get_vertices(trans: &ProxyTransaction, item: &serde_json::Map<String, JsonValue>) -> Result<JsonValue, IronError> {
    let q = get_json_obj_value::<VertexQuery>(item, "query")?;
    execute_item(trans.get_vertices(&q))
}

fn delete_vertices(
    trans: &ProxyTransaction,
    item: &serde_json::Map<String, JsonValue>,
) -> Result<JsonValue, IronError> {
    let q = get_json_obj_value::<VertexQuery>(item, "query")?;
    execute_item(trans.delete_vertices(&q))
}

fn get_vertex_count(trans: &ProxyTransaction, _: &serde_json::Map<String, JsonValue>) -> Result<JsonValue, IronError> {
    execute_item(trans.get_vertex_count())
}

fn create_edge(trans: &ProxyTransaction, item: &serde_json::Map<String, JsonValue>) -> Result<JsonValue, IronError> {
    let key = get_json_obj_value::<EdgeKey>(item, "key")?;
    execute_item(trans.create_edge(&key))
}

fn get_edges(trans: &ProxyTransaction, item: &serde_json::Map<String, JsonValue>) -> Result<JsonValue, IronError> {
    let q = get_json_obj_value::<EdgeQuery>(item, "query")?;
    execute_item(trans.get_edges(&q))
}

fn delete_edges(trans: &ProxyTransaction, item: &serde_json::Map<String, JsonValue>) -> Result<JsonValue, IronError> {
    let q = get_json_obj_value::<EdgeQuery>(item, "query")?;
    execute_item(trans.delete_edges(&q))
}

fn get_edge_count(trans: &ProxyTransaction, item: &serde_json::Map<String, JsonValue>) -> Result<JsonValue, IronError> {
    let id = get_json_obj_value::<Uuid>(item, "id")?;
    let type_filter = get_optional_json_obj_value::<Type>(item, "type_filter")?;
    let direction = get_json_obj_value::<EdgeDirection>(item, "direction")?;
    execute_item(trans.get_edge_count(id, type_filter.as_ref(), direction))
}

fn get_vertex_metadata(
    trans: &ProxyTransaction,
    item: &serde_json::Map<String, JsonValue>,
) -> Result<JsonValue, IronError> {
    let q = get_json_obj_value::<VertexQuery>(item, "query")?;
    let name = get_json_obj_value::<String>(item, "name")?;
    execute_item(trans.get_vertex_metadata(&q, &name))
}

fn set_vertex_metadata(
    trans: &ProxyTransaction,
    item: &serde_json::Map<String, JsonValue>,
) -> Result<JsonValue, IronError> {
    let q = get_json_obj_value::<VertexQuery>(item, "query")?;
    let name = get_json_obj_value::<String>(item, "name")?;
    let value = get_json_obj_value::<JsonValue>(item, "value")?;
    execute_item(trans.set_vertex_metadata(&q, &name, &value))
}

fn delete_vertex_metadata(
    trans: &ProxyTransaction,
    item: &serde_json::Map<String, JsonValue>,
) -> Result<JsonValue, IronError> {
    let q = get_json_obj_value::<VertexQuery>(item, "query")?;
    let name = get_json_obj_value::<String>(item, "name")?;
    execute_item(trans.delete_vertex_metadata(&q, &name))
}

fn get_edge_metadata(
    trans: &ProxyTransaction,
    item: &serde_json::Map<String, JsonValue>,
) -> Result<JsonValue, IronError> {
    let q = get_json_obj_value::<EdgeQuery>(item, "query")?;
    let name = get_json_obj_value::<String>(item, "name")?;
    execute_item(trans.get_edge_metadata(&q, &name))
}

fn set_edge_metadata(
    trans: &ProxyTransaction,
    item: &serde_json::Map<String, JsonValue>,
) -> Result<JsonValue, IronError> {
    let q = get_json_obj_value::<EdgeQuery>(item, "query")?;
    let name = get_json_obj_value::<String>(item, "name")?;
    let value = get_json_obj_value::<JsonValue>(item, "value")?;
    execute_item(trans.set_edge_metadata(&q, &name, &value))
}

fn delete_edge_metadata(
    trans: &ProxyTransaction,
    item: &serde_json::Map<String, JsonValue>,
) -> Result<JsonValue, IronError> {
    let q = get_json_obj_value::<EdgeQuery>(item, "query")?;
    let name = get_json_obj_value::<String>(item, "name")?;
    execute_item(trans.delete_edge_metadata(&q, &name))
}

fn execute_item<T: Serialize>(result: Result<T, Error>) -> Result<JsonValue, IronError> {
    let value = result.map_err(|err| create_iron_error(status::InternalServerError, format!("{}", err)))?;

    Ok(serde_json::to_value(value).map_err(|err| {
        create_iron_error(
            status::InternalServerError,
            format!("Could not serialize results: {}", err),
        )
    })?)
}


pub fn get_transaction() -> Result<ProxyTransaction, IronError> {
    Ok(statics::DATASTORE.transaction().map_err(|err| {
        create_iron_error(
            status::InternalServerError,
            format!("Could not create datastore transaction: {}", err),
        )
    })?)
}

pub fn read_json<T>(body: &mut Body) -> Result<Option<T>, IronError>
where
    for<'a> T: Deserialize<'a>,
{
    let mut payload = String::new();
    let read_result: Result<usize, io::Error> = body.read_to_string(&mut payload);

    if let Err(err) = read_result {
        return Err(create_iron_error(
            status::BadRequest,
            format!("Could not read JSON body: {}", err),
        ));
    }

pub fn create_iron_error(status_code: status::Status, err: String) -> IronError {
    let body = serde_json::to_string(&json!({ "error": err })).unwrap();
    let json_content_type_modifier = HeaderModifier(ContentType(get_json_mime()));
    let modifiers = (status_code, json_content_type_modifier, body);
    IronError::new(SimpleError::new(err), modifiers)
}


